- Complete Python string parsing

- Complete shell string parsing (termination on things other than EOL
  and whiteapce).

- Licensing header

- Debugging & verbosity level

- Should the name of map be changed? f as in osh? apply? map doesn't
  really make sense when used as a generator. Could have gen handle
  this case through a function argument mutually exclusive with other
  args. So "gen 5" works like it always had, but "gen (5)" generates a
  5?!

- What happens to processes that disappear? E.g. ps | .... ps yields
  non-existent processes which are then used downstream. Can this even
  happen?

- ps: If commandline blank, take contents of status file? That's what
  ps appears to do.

----------------------------------------------------------------------

File objects

- File navigation (parent, children, ...). Sort of works. Should
  _getattr() wrap a path (if delegation returns one) into a File?

----------------------------------------------------------------------

Bash:

- What if there is an arg that is significant to marcel parsing, e.g. [, (.

- shlex.quote() usage, and wildcards need to be
  reconsidered. Automatically quoting everything is wrong, (bug 38). So
  maybe the problem is that bash is wrong. Need to preserve the bash
  args exactly as written, quotes included, and pass it all to Popen. As
  things stand, we lose the quotes during parsing, and then add them
  back unconditionally.
  
  Globbing is tricky because it then requires great care to quote and
  escape properly, e.g. a\ b*, 'a b'*, 'a b*', (the first two are the
  same, the last has no wildcard).

----------------------------------------------------------------------

- Organize internal ops -- Fork, LabelThread

- out.receive does a lot of work. Precompute whatever can be.

- How do exit codes fit in?

----------------------------------------------------------------------

Glob patterns and marcel syntax both use [].

    M jao@cheese:/tmp/d$ ls [a-c]* | rm
    Parsing error at position 4 of "ls [a-c]* | rm": Expected string or pipe

Could handle the situation by being context-sensitive during the
parse.

This is going to be a problem now that pipelines can be args.

----------------------------------------------------------------------

Provide a way to specify farcel config path. Maybe as a property of
the cluster.

----------------------------------------------------------------------

Distinct color for broken symlink.

----------------------------------------------------------------------

Tab completion for command should distinguish between first op of
pipeline and subsequent ones. I.e., only show those ops that can be
used in the current position within the pipeline.

----------------------------------------------------------------------

What happens if an arg that is supposed to be a pipeline is actually a
string looking exactly like a pipeline ref?

----------------------------------------------------------------------

Job should be in marcel.object. Maybe.

----------------------------------------------------------------------

Add notion of current job, and then allow bg/fg ops to omit args.

----------------------------------------------------------------------

Would multiprocessing.Process provide better streaming than
subprocess.Popen? I.e., not waiting for op to complete.

----------------------------------------------------------------------

Make Bash.INTERACTIVE_EXECUTABLES an environment variable, so that it
can be customized by the user.

----------------------------------------------------------------------

ps flags. E.g., -a

----------------------------------------------------------------------

Should expand operate on filenames? Might be better to have a separate
command for that, e.g. cat.

----------------------------------------------------------------------

Import bash env?

----------------------------------------------------------------------

Help:

- Allow for indented paragraphs. Equating indent and non-wrapping is
  probably a bad idea. Maybe find a Python markdown implementation?
  Still need colorizing.

Use these for help.

----------------------------------------------------------------------

Red:

- Need a red function for creating a list. + isn't a good choice, since it
  already does expected things for numbers and strings. 

- Can squish be eliminated in favor of some variation of red? 

Could at least generalize similar to expand. E.g. squish 1 would take
a sequence in position 1 and squish just that. So

(1, [[1]])
(2, [[2], [2]])
(3, [[3], [3], [3]])

 ->

(1, [1])
(2, [2, 2])
(3, [3, 3, 3])

----------------------------------------------------------------------

Need to handle {} chars in markup. See help_operator.py.

Should help output go through more?

----------------------------------------------------------------------

Configuration:

- Look in ~, /etc/marcel.

- Be able to specify config file (or multiple locations) in startup.

Why is define_colors necessary? Just assign Colors to variables, which 
can then be referenced in define_color_schema, and define_prompt?

similarly, get rid of define_prompt, define_continuation_prompt.

Unify environment and config: Make the namespace the repository of env vars.


Need arbitrary colors in markup, e.g. so that colorized prompt can be
described.


use bold = True, or BOLD | ITALIC?

----------------------------------------------------------------------

Cleanup:

- Markup 2.0.

- Modify docs to use the markup 2.0.

- Get rid of define_color, define_prompt, define_continuation_prompt.

- Merge env and config. Env vars are just top-level symbols in the
  namespace.



Env, config, global_state:

main: 

    - self.env = Environment(config_path)

    - self.global_state = GlobalState(env)

    - Main loop calls self.env.prompts() which mostly delegates to config.

    - Execution passes self.global_state to parser.

    - Main defines update_env_vars, which is used by JobControl to update
      vars modified by Job running in another process. These call env.setvar
      which then ends up in config.

env:

    - Reads parts of environment (user, host, homedir, current dir)

    - __init__ gets config_path from caller (main)

    - Sets env vars, self._vars

    - Create config and store in self._config.

    - self._color_scheme = color scheme from config.

    - Implements current dir operations: cd, pushd, popd, dirs,
      pwd. Dir stack is maintained in config, as a var. Problem with
      this approach: User can modify it directly, unless setvar() 
      checks for it. Same with PWD, which works in bash, but leads to
      weird results, e.g.

            jao@cheese:~$ PWD=/tmp
            jao@cheese:/tmp$ pwd
            /home/jao

    - Access to cluster, config, color_scheme, all of which reside in config.

config:

    - Has self._env_vars, prompt, continuation prompt.

    - self.function_namesspace is the namespace in which commands run. Defined by
      executing .marcel.py, in read_config. 

    - read_config puts Color, PROMPT, PROMPT_CONTINUATION, COLOR_SCHEME, define_cluster
      in globals(), passes to exec(.marcel.py). Then, COLOR_SCHEMA is put in function namespace.
      Should probably put everything there.

GlobalState:

    - Attached to parser, pipelines, available everywhere as a result.

    - Has env, edited_command, op_modules.

    - Provides function_namespace via delegation.


Cleanup:

+ Merge Environment and Configuration. Get rid of Configuration.

+ Put directory logic into its own class.

- Replace GlobalState by Environment. Move GlobalState fields into
  Environment.

+ After execing .marcel.py, copy locals into globals. globals replaces
  function_namespace.

+ Move VERSION from env to an environment variable, MARCEL_VERSION.

----------------------------------------------------------------------

History commands

- If history were in the namespace, then edited_command wouldn't need
  special handling.
