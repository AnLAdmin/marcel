- Complete Python string parsing

- Complete shell string parsing (termination on things other than EOL
  and whiteapce).

- Licensing header

util.py:

- quote

- Debugging & verbosity level

- Make File comparisons work -- based on absolute path.

- Should the name of map be changed? f as in osh? apply? map doesn't
  really make sense when used as a generator. Could have gen handle
  this case through a function argument mutually exclusive with other
  args. So "gen 5" works like it always had, but "gen (5)" generates a
  5?!

- What happens to processes that disappear? E.g. ps | .... ps yields
  non-existent processes which are then used downstream. Can this even
  happen?

- ps: If commandline blank, take contents of status file? That's what
  ps appears to do.

- more/less commands

- File navigation (parent, children, ...)

- ^emacs works -- a new window running GUI emacs is created. So does
  ^emacs -nw, doing exactly the right thing (non-graphical, in current
  terminal). But ^vi does not. Nothing appears to happen. But vi is
  listening for input, so :q exits. stderr complains about not being a
  terminal, but this isn't visible. Vi DOES work if subprocess.run
  omits stdout=PIPE and stderr=PIPE.

- redirection

- Organize internal ops -- Fork, LabelThread

- osh1 fork has to be first in top-level pipeline. Relax this?

- LOOK AT SHLEX MODULE -- COMMAND-LINE PARSING AND QUOTING

- .marcel.py might want a cluster named jao and a terminal profile
  named jao. Need separate namespaces for these things.

- out.receive does a lot of work. Precompute whatever can be.

- pushd/popd

- How do exit codes fit in?

- Redirection: < > >>. > and >> are taken care of by out -f and out -a,
  aren't they?

----------------------------------------------------------------------

Executables (without the bash op)

- How to invoke the bash --interactive flag?

- What if there is an arg that is significant to marcel parsing, e.g. [, (.

----------------------------------------------------------------------

Glob patterns and marcel syntax both use [].

    M jao@cheese:/tmp/d$ ls [a-c]* | rm
    Parsing error at position 4 of "ls [a-c]* | rm": Expected string or pipe

Could handle the situation by being context-sensitive during the
parse.

----------------------------------------------------------------------

Get rid of "from ... import ..."

----------------------------------------------------------------------

Provide a way to specify farcel config path. Maybe as a property of
the cluster.


----------------------------------------------------------------------

Can squish be eliminated in favor of some variation of red? 

Could at least generalize similar to expand. E.g. squish 1 would take
a sequence in position 1 and squish just that. So

(1, [[1]])
(2, [[2], [2]])
(3, [[3], [3], [3]])

 ->

(1, [1])
(2, [2, 2])
(3, [3, 3, 3])

----------------------------------------------------------------------

Need a flag for cp, mv, to prevent clobbering existing files. (Check
before doing anything, even though that isn't foolproof.)

----------------------------------------------------------------------

mv looks buggy. Setup considers last filename as target. This is
BEFORE glob expansion, which is wrong. Write more tests, fix code.

bash: mv glob ... 

- Takes the last identified file as the target. So mv * is fine.

- EXCEPT if the last item on the command line is a glob, which
  describes no files, then the item itself is interpreted as a
  filename. And if THAT doesn't exist, then mv complains about there
  being no target. So mv a* b* moves everything into the last thing
  identified by b*. If b* doesn't identify anything, then "b*" is
  assumed to be the file. 

- But it ALSO depends on how many things are being moved. If nothing
  is identifed by b*, then mv a* b* will work as follows:

  - a* identifies > 1 file: Complain that directory b* does not exist.
  - a* identifies 1 file: Move the matched file to "b*".
  - a* identifies 0 files: Complain that "a*" does not exist.

mv a* b* (a* > 1 file, b* does not exist) protects against
accidentally using the last a* file/dir as a target. Which is good.

Have marcel be more explicit:

- Last FILENAME is the target.

- Take files being moved from upstream if one FILENAME is specified
  (the target). I.e., base it on the number of FILENAMEs, not the
  number of qualifying things after glob expansion.

----------------------------------------------------------------------

Distinct color for broken symlink.

----------------------------------------------------------------------

Computing ls.base (used to compute file.display_path) isn't quite
right, for symlink to directory. Need to survey what bash does,
decide on correct behavior, implement and test. Related to handling
of -HL flags for ls.


----------------------------------------------------------------------

cp, mv, ln, rm.

- Allow piping files in.

- Tab completion

----------------------------------------------------------------------

Tab completion for command should distinguish between first op of
pipeline and subsequent ones. I.e., only show those ops that can be
used in the current position within the pipeline.

----------------------------------------------------------------------

Tab completion for flags of executables.

----------------------------------------------------------------------

Clean up parser to prepare for more general handling of pipelines:

- @fork [ ... ] currently:

    - fork_start and fork_spec grammar states and actions.
    
    - InProgress has fork_spec field.

    - finish_pipeline assumes that a fork op is being completed.

- Generalize:

    + Treat fork like any other op. START action creates an op just
      like for a string. Don't need START_FORK and FORK_SPEC states.

    + Choice between LocalFork and RemoteFork can't be done by
      create_fork.  Keep choice inside Fork op, delegate instead of
      inherit.

    + Fork has to be a more standard op. The only thing special about it
      is the syntax used to invoke it, @.

    + create_op also has some op-specific logic, distinguishing op
      from executable, and using the bash operator in the latter case.

    + finish_pipeline: Remove special handling of fork op. The
      pipeline just goes into op.args.

----------------------------------------------------------------------

create op:

        op_module = marcel.opmodules.OP_MODULES.named(op_name)
        if op_module:
            current.op = getattr(op_module, op_name)()
        else:
            # op_name might be an executable
            if is_executable(op_name):
                # Execute via the bash op, in which case op_name becomes the first argument.
                bash_module = marcel.opmodules.OP_MODULES.named('bash')
                current.op = getattr(bash_module, 'bash')()
                current.args.append(op_name)
            else:
                raise UnknownOpError(self.text, op_name)

----------------------------------------------------------------------

What happens if an arg that is supposed to be a pipeline is actually a
string looking exactly like a pipeline ref?

----------------------------------------------------------------------

cd doesn't work because it's running in a Process. Doesn't affect the
env visible to the main process.

----------------------------------------------------------------------

Job should be in marcel.object.

----------------------------------------------------------------------

Add notion of current job, and then allow bg/fg ops to omit args.

----------------------------------------------------------------------

Would multiprocessing.Process provide better streaming than
subprocess.Popen? I.e., not waiting for op to complete.

----------------------------------------------------------------------

Can GlobalState.only obviate pipeline.global_state? And other places
where GlobalState is cached?
