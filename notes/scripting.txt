- marcel has no control constructs: loops, functions, if/else, etc.

- It's dumb to invent a new language.

- marcel already relied on Python.

So there are a few options:

1) Allow Python code, beyond lambdas, inside marcel code. 

2) Provide a Python API for executing marcel code.

3) Python API for marcel, similar to osh API.

----------------------------------------------------------------------

1) Allow Python code, beyond lambdas, inside marcel code. 

#1 is kind of clumsy. There would have to be some bracketing syntax to
delimit Python code (as is currently the case for functions). E.g.

[[
def some_function(...):
   ...

for foo in bar:
    function(foo)
]]

- Syntax highlighting wouldn't work.

- This actually isn't bad. Functions defined this way could be
  invoked.

- But when is that code run? (for foo ...)

- Output and errors could be streamed in the usual way.

- What is the control flow among these blocks of code?

----------------------------------------------------------------------

2) Provide a Python API for executing marcel code.

E.g.

    marcel('''ls -fr | \
              map (f: (f.suffix.lower, 1)) | \
              red . +''')

which could yield a list or iterator.

- Not quite as clean as a shell combining shell features and control
  in the same context. The quoting is ugly.

- The mapping function is a Python function, embedded in a string,
  embedded in Python. Weird and ugly.

----------------------------------------------------------------------

3) Python API for marcel, similar to osh API.

marcel(ls('abc*', recursive=True, file=True) | 
       map(lambda f: (f.suffix.lower, 1)) |
       red(None, '+'))

- Cleaner combination of shell and language.

- But quoting of flags is ugly.

- + has to be quoted. Maybe function('+')

- Should args to ls be a single string? Or broken into separate args?

----------------------------------------------------------------------

- setup1() has to do thorough checking of args, of the sort that
  argparse does now.

- CLI should invoke op class constructor directly, e.g. Ls(). Reserve function
  for API, e.g. ls()

----------------------------------------------------------------------

Error handling:

- run: out() appended to pipeline, which means ordinary output and
  Error output, all go to stdout, which is fine.

- gather:

    - gather appends map operator at end, to gather output.
      Errors are missed.

    - Could fix this, by tweaking Error handling behavior, and
      keep Errors in the output stream and collection. Is this
      desirable? Preserves ordering. 

    - Could return errors in a separate list, but:

        - Loses ordering between ok and erroneous output.

        - This no longer works:

               for x in gather(...)

          because gather returns two things. This also doesn't work:

               f(gather(...))

    - Allow for error handling function?

- out: Error raises exception? Returns error?


Error handling choices are general -- should apply to CLI, and all APIs:

- Default: Handle it with out, if out is present. But what is the default
  if there is no terminal out operator? Does printing the error when it occurs
  produce the same ordering? It should.

- Exception (killing command)

- Call function

......................................................................

Error handling:

BaseOp.send():

    - Calls self.receiver.receive_input_or_error().

    - If that throws KillAndResumeConnection, call self.receiver.receive_error(Error(e))

BaseOp.receive_input_or_error():

    - if input is Error, pass to self.receive_error()

    - Otherwise, call self.receive(). 

    - And if that throws an Exception, call self.receive_error(Error(e))

BaseOp.receive_error():

    - self.send(error)

Pipeline.receive():

    - Starts execution with self.first_op.receive(x).

    - If that raises KillAndResumeException, call receiver.receive_error(Error(e))


If we had send_error, then we wouldn't need receive_input_or_error to
check to see if the input is an error. 

Can print an Error when KillAndResume is raised. Don't have Out op
implement receive_error. Still need to carry the Error along the
stream, however, to get relayed from remote execution, and then be
labelled by LabelThread.

Problem with this approach: ls can complain about permission errors,
and then move on with its recursion. ls.visit does
self.send(Error(...)). Raising a KillAndResume ends the
ls. KillAndResume mechanism is OK usually, I think, but not in this
case. So RELYING on raise of KARE doesn't work here. 

----------------------------------------------------------------------

Why does BaseOp need __getstate__ and __setstate__ which don't do
anything interesting?
