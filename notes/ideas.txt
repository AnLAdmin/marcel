
send/receive vs. yield

Could write operators as python generators, providing output via
yield. For operators other than the first, an input source is
needed. E.g., here is map.receive:

    def receive(self, x):
        self.send(self.f(*x))

Instead, it would be

    def run(self):
        try:
            input = self.input.run()
            while True:
                yield self.f(next(input))
        except StopIteration:
            ...

So instead of calling self.send (implying something downstream), you
know about the thing upstream (self.input). And yield is native
python, not an osh API.

So for the first item in a pipeline, it would just be "yield", and
there is no dependence on other operators. This allows ps(), ls(),
etc. to be used as functions or operators.
        
----------------------------------------------------------------------

Realization!

processes() is a function returning a list of Process. ps() is a
command generating a stream of Process. They can't be unified without
making processes() generate a stream, perhaps using yield. But in
other situations, we really want ordinary functions, e.g. for use in
map and select.

So:

ls:

- The kinds of functions used in map and select are ordinary python
  functions. Leave those alone, they are fine as is.

- If we want to unify ps()/ps, or ls()/ls, then we need python
  generators. 

- Allow cd to be mid-pipeline. It establishes an env that applies
  downstream only. I.e., logically, each op establishes a new COPY of
  the env, and can make changes not visible upstream.

----------------------------------------------------------------------

Argument invocation from Nu: https://www.nushell.sh/blog/2020/06/09/nushell_0_15_0.html

Pipeline used to provide arg value. Sort of like API gather or
first. Functions are already allowed, so this is easy.

----------------------------------------------------------------------

From https://erayerdin.hashnode.dev/nushell-shell-redefined-ck9gbnphi06oucss1fvt0sgt4

- Object introspection via command.

- Understand textual formats, e.g. json. "open" command to open a file
  and pipe it.

- Look into direnv. Nushell has some idea of location-sensitive
  environment. A directory is a "shell", and I guess has its own
  environment.
