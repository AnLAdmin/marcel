Introduction

Marcel is a shell. The main idea is to rely on piping as the primary
means of composition, as with any Unix or Linux shell. However,
instead of passing strings from one command to the next, marcel passes
Python values: builtin types such as lists, tuples, strings, and
numbers; but also objects representing files and processes.

Linux has extremely powerful commands such as awk and find. Most
people know how to do a few simple operations using these
commands. But it is not easy to exploit their full power due to their
reliance on extensive "sublanguages" which do:

    Filtering: What data is of interest?
    Processing: What should be done with the data?
    Formatting: How should results be presented?

Marcel has no sublanguages. If you know Python, then you already know
the language used by marcel to exploit the full power of marcel's
operators.  You use marcel operators combined with Python code to
filter data, process it, and control command output.

The commands and syntax supported by a shell constitute a language
which can be used to create scripts. Of course, in creating a script,
you rely on language features that you typically do not use
interactively: control structures, data types, and abstraction
mechanisms (e.g. functions), for example. Viewed as a programming
language, shell scripting languages are notoriously bad. I didn't
think it was wise to bring another one into the world. So marcel takes
a different approach, using Python as a scripting language, (see below
for more on scripting).


Installing marcel

To install marcel for your own use:

python3 -m pip install marcel

To install for the entire system:

sudo python3 -m pip install --prefix /usr/local marcel

(Or change /usr/local to whatever makes sense for your system.)

Assuming marcel installs successfully, start it by running marcel:

    marcel

And then run the version command to see that marcel is working:

    version


Help

Marcel's help facility provides reference information on all aspects
of marcel: concepts, operators, and objects. Running "help" provides
top-level usage information, and an initial list of topics. Running
"help TOPIC" provides help on the given topic.


Basic usage

As with any other shell, you type in commands at the prompt.  In
marcel terminology, an operator is a single command, built in to
marcel. For example, the pwd operator prints the current directory:

    pwd

You can also run host OS executables. Marcel doesn't have a builtin
operator named which, but you can run which (on Linux and Mac, at
least), because which is an executable in the host operating system.

    which cc

In some cases, marcel and the host OS will have operators and commands
with the same name. In these cases, the marcel operator serves the
same general purpose as the host OS executable, but typically has
fewer options, and its behavior may have been modified to fit into
marcel better. An example of this is ls. Run "help ls" to see details
of the ls operator. 

    cd ~/git/marcel/marcel
    ls

Marcel maintains a set of environment variables. Like many other Linux
shells, there are entries for USER (your username), PWD (the current
directory), and there are other entries. You can examine the complete
environment by running the env command:

    env

You can also examine one of the variables by enclosing the variable's
name in parentheses, e.g.

    (USER)

In general, parentheses delimit Python expressions, so you can do
arithmetic:

    ((1 + 5 ** (1/2)) / 2)

or computations involving other Python types, e.g.

    ('abc' * 3)
    (list(range(5)))

The history command generates a stream containing the most recent
commands you have entered:

    history

You can edit the most recent command by running the edit command.  Or
to edit an earlier command, run "edit N", where N is the identifier of
a command printed by the history operator. As in other shells, the
value of the EDITOR environment variable can be set to determine the
editor to be used for editing commands.

*** Command-line editing.

You can also run previous commands. !! runs the most recent command,
and !N runs command N.


The marcel environment 

As with any other shell, marcel has environment variables. In Python
terms, these variables exist in a namespace that is made available to
marcel commands. So, for example, you can examine the value of the
EDITOR variable as follows:

    (EDITOR)

The parentheses delimit the Python expression EDITOR. That symbol is
located in marcel's namespace (the environment), and the value is
printed.

You can create or modify environment variables by using convnetional
assignment syntax, e.g.

    x = (1)
    (x)

This assigns the integer 1 to x, and then prints out the value of x. 
By contrast, this assigns the string '1' to x: 

    x = 1

I.e., the marcel command-line is string-oriented. If you want to work
with values of other types, these values need to be created as Python
expressions, and Python expressions need to be enclosed in
parentheses.

Your environment variables can be structured types too. For example,
you can assign a list:

    x = ([1, 'two', 4-1])
    (x)

[1, 'two', 4-1] is a list, and by enclosing this expression in
parentheses, the value of the list can be assigned to the variable x.

Some Python types, like lists, can be updated, and this can be done
through marcel. For example, to append to x's list:

    (x.append(4))
    (x)

Finally, environment variables can be deleted:

    delete x
    (x)


Configuration

Marcel is customized on startup by executing ~/.marcel.py. You don't
need to create this file, it will be created for you the first time
you run marcel. What ~/.marcel.py does is to initialize the marcel
namespace -- it defines symbols that are available for use in marcel
commands, or that customize marcel's behavior.

The default ~/.marcel.py begins with an import:

    from marcel.builtin import *

This brings in a few functions and types that are important in marcel
usage. For example, the symbol now is defined to be time.time(),
allowing you to call now() to obtain seconds since the epoch:

    (now())

The default ~/.marcel.py also provides a rudimentary definition of
PROMPT, which controls the appearance of your shell prompt:

    PROMPT = [lambda: PWD, ' $ ']

PWD is the environment variable identifying your current
directory. 'lambda: PWD' creates a function, returning the value of
PWD each time a prompt is displayed. ' $ ' is a string printed
following the value of PWD. This definition results in a prompt that
looks like this:

    /home/jao/git/marcel $ 

Another variable, PROMPT_CONTINUATION defines the prompt to be used
for multi-line commands.

Colors and the color scheme

Marcel colorizes its prompt, and the output describing some objects,
e.g. Files and Processes. 

Marcel includes a Color type, that allows you to defined your own
colors. A Color is constructed by providing RGB (red/green/blue)
values, in the range 0-5. So white would be Color(5, 5, 5), and pure red
would be Color(5, 0, 0). Colors are applied to text, and you can
include styling attributes BOLD, ITALIC or both (BOLD | ITALIC) as a
last argument to color, e.g. Color(5, 3, 0, BOLD).

Marcel relies on a ColorScheme object for colorizing output. The
ColorScheme is a set of colors for specific purposes. 

*** COMPLETE THIS ONCE BUG 86 is fixed


Navigation

Marcel keeps track of the current directory, and a directory stack, as
in other shells. (The current directory is always the top item on the
directory stack.) The commands for operating on directories are the
same as in other shells:

- pwd: prints the current directory.

- cd: Change the current directory to the one specified on the command
  line.

- pushd: Push the specified directory onto the directory
  stack. Without arguments, swap the top two directory stack
  items. This causes the current directory to change.

- popd: Remove the top item on the directory stack, causing the
  current directory to change.

- dirs: ***

*** DIRS env var

Streams and objects

The ls command lists files, like any Linux shell. But there are
important differences. The Linux ls executable prints strings
describing files, either multiple file names per line; or, if you
specify the -l flag, then one string per line, with each line
including file attributes such as mode, modification time, owner,
group, and others. I.e., the printing and formatting logic is part of
the ls executable.

By contrast, marcel's ls operator generates a stream of File objects,
and has no responsibility for printing or formatting -- if you run
"help ls" you will see no such options.

The stream of File objects generated by ls can be passed to the output
operator, out:

    ls | out

out takes a stream of objects, and prints each, one per line. The net
effect is a listing very much like what you would see by running "ls
-l" from bash.

Marcel appends an out operator to your command line, if you don't
specify it yourself. So you can get the same listing of files by just
writing ls:

    ls

out has a variety of options controlling how the incoming stream of
objects is printed. These include writing to a file. For example, if
you want to save the result of ls in /tmp/files:

    ls | out -f /tmp/files

Or to append to /tmp/files:

    ls | out -a /tmp/files

(You can redirect using > and >>, but those operate on environment
variables, not files. This is discussed in more detail later.)


Functions

Several marcel operators take functions as arguments. Functions are
written in Python. For example, the files produced by the ls operator
can be piped to the select operator, which uses a function to keep
only files modified in the past hour:

    ls | select (lambda f: now() - f.mtime < hours(1))

In marcel, Python expressions are always delimited by
parentheses. Here, the function takes one argument, f, which will be
bound to Files piped in from ls. now() is a function built in to
marcel which returns the current time, seconds since the
epoch. f.mtime returns the modification time of file f. hours(1) is
another builtin function that returns the number of seconds in one
hour.

The net effect is to filter the Files returned by ls by keeping only
those modified in the last hour. Remember that an out operator is
appended if needed, so this command prints the qualifying files.

The map operator uses a function to transform incoming data. For
example, this command lists files (only, thanks to the -f flag) and
prints the file's name and number of lines in each:

    ls -f | map (f: (f.name, f.size))

You can write functions with no arguments. For example, to evalues
2**50:

    map (2**50)

In cases like this -- map calling a function with no arguments, as the
first thing on the command line -- you can omit writing 'map', it will
be understood. So this works too:

    (2**50)

Functions run in the marcel namespace, a Python namespace maintained
by marcel. This namespace includes environment variables, so you can
use this abbreviated notation to examine environment variables:

    (USER)

Or to do computations with them:

    (USER[::-1])

You can add symbols to the marcel namespace in a number of ways:

- import modules in ~/.marcel.py, the configuration file.
- Define symbols in ~/.marcel.py.
- Use the import statement

For example, math.pi is not present in the marcel namespace by
default:

    (pi)
    (math.pi)

However, you can import math:

    import math
    (math.pi)

("import math *" would import the symbols contained in math, similar
to the Python statement "from math import *.)

    

Pipelines

A sequence of operators, connected by pipes, is a *pipeline*. While
marcel usage often involves just running one command -- one pipeline
-- after another, you can also store pipelines for later use, similar
to the writing of a function in a programming language.

For example, here is a pipeline that searches the current directory
recursively, and reports all files ending in '.py':

    py = [ls -fr | select (f: f.suffix == '.py')]

This creates a pipeline, and assigns it to the environment variable
py. You can examine the value of this variable:

    (py)

Wherever it is run, it will explore the current directory,
recursively, printing those files whose extension is '.py'.

You can generalize this, by paramaterizing the pipeline. For example,
here is a pipeline that looks for any given extension:

    ext = [e: ls -fr | select (f: f.suffix == e)]

You can specify a value for the parameter e positionally:

    ext .py

Or, if you prefer, you can use a short flag, if the parameter is a
string of size 1:

    ext -e .py

You can also use a long option, regardess of the length of the
parameter's name, e.g.

    ext --e .py

Saving and recalling streams

Streams carry objects between operators. There are two special
operators for saving and recalling streams. The store operator stores
a stream in an environment variable. For example, using the ext
pipeline, I can find and save all .txt files in the variable txt:

    ext .txt | store txt

This will replace the current value of txt, if there is one. Or, to
append to the current value:

    ext .txt | store --append txt

(And --append can be abbreviated to -a.)

The load operator retrieves the stored data, and writes it to the
output stream. So for example, to select files in txt larger than
1,000,000 bytes:

    load txt | select (f: f.size > 1000000)

The store and load operators have special syntax. For example, the
previous example could be written as:

    txt > select (f: f.size > 1000000)

At the end of a pipeline, > denotes the store operator, e.g.

    ext .txt > txt

And >> is equivalent to store --append.

> can be used to copy from one variable to another, e.g.

    txt > txt_copy

which is equivalent to load txt | store txt_copy.

----------------------------------------------------------------------

Pipelines can also be used as arguments to operators. 

- ifthen, ifelse
- set ops
- join


Escapes

- bash
- sudo

Databases


Remote


Scripting

- marcel scripts
- marcel.api

Uncategorized

- ps
- sort, unique, reverse
- head, tail
- window
- version
- red
