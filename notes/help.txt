ArgParser cleanup

Cleanup ArgParser so that a ColorScheme can be supplied to it, so that
help messages can be colorized.

- parse: 

  + Pass in op_modules from Main.
  + Use it instead of OP_MODULES.
  + Parser no longer needs global_state (it was just attached to the
    arg parser)

- ArgParsers

  + Take global_state as input, save on marcel.core.ArgParser.
  - Get help strings: description, epilog, from the module,
    and pass the to the ArgParser constructor, or otherwise attach
    them to the ArgParser.

- core ArgParser

  - Colorize the description and epilog using colorscheme obtained from
    global_state.

- Ops

  + Get rid of argparser class field.
  + Get rid of arg_parser() function from ops and core.Op.

- Other cleanup

  - Eliminate dependencies of marcel modules on marcel.op
    modules. E.g. out, used by Command.

----------------------------------------------------------------------

Formatting:

Colorizing throws off text-wrapping because the escape characters are
not zero-width. There is a colorizing text wrapper for argparse, but
it is 3rd party.

ALSO: paragraphs not preserved. Maybe use RawDescriptionTextHandler
and take over formatting completely? There will still be a problem in
wrapping text with escape codes.



Alternative:

- Have arg parser use RawDescriptionTextHandler

- Start with the marked-up text, e.g. '''This is a {flag} blah blah blah'''. 

- Note the indexes of words in the markup: markup_positions

- Remove the markup (plaintext) and wrap text (wrapped).

- Use markup_positions to re-insert markup in the wrapped text
  (allowing for words split by hyphenation).

- Colorize.

----------------------------------------------------------------------

Markup:

{} isn't enough. Need more markup, e.g. for headings:

- {}: highlight term being defined

- b{}: bold

- i{}: italic

- f{}: highlighting meant to indicate fixed-width. E.g., an object
  type.

- indented text: don't wrap

----------------------------------------------------------------------

Implementation (after a couple of failed attempts):

- Structure text as a list of Blocks, where a Block is one of:

  - EMPTY: A line of length 0.

  - INDENTED: A line beginning with whitespace

  - PARAGRAPH: A sequence of lines beginning with non-whitespace.

- PARAGRAPH is a sequence of Tokens, where a Token is one of:

  - WHITESPACE: A maximal sequence of whitespace.

  - TEXT: A maximal sequence of non-whitespace excluding markup.

  - MARKUP: x{...}

  So "abc n{this is marked up}, def" ->

  TEXT: "abc"
  WHITESPACE: " "
  MARKUP: n{this is marked up}
  TEXT: ","
  WHITESPACE: " "
  TEXT: "def"

The idea is to be able to easily identify where the markup is located
within a PARAGRAPH that has been transformed by removing markup and
then wrapping. This can be done by recording, for a MARKUP:

- Number of TEXT characters preceding the MARKUP (including the text
  inside preceding MARKUPs.

- Length

INDENTED line is like a paragraph. Might have markup. Handle it like a
paragraph, but don't wrap it.

----------------------------------------------------------------------

Everything above is for the output from argparse's -h flag. Still need
to provide a help command:

- To provide for top-down help, e.g. "help" will tell you how to get
  started (ops, executables, objects).

- To provide help for non-command things:

  - Concepts
  - Pipelines
  - Remote execution
  - Objects

Help structure:

     help
         configuration
         environment
         concepts
             pipeline
             fork
         operators
         objects
             file
             process
             color_scheme

- help command is: help [topic]. 

- topic names are globally unique.

- "help OP" should produce the same output as "OP -h". How does this
  work? Does "help OP" run "OP -h"? Or are help files generated?

- In marcel/doc, put doc for topic T in help_T.py. Then, put doc in
  strings, e.g. HELP = '''...'''. By using .py, it is easy to extend
  help docs in the future, with vars, lists, etc.

- BUT: this means that we import a module for doc. Does that module
  stay in memory? Probably not a lot of bloat. Removing module from
  the containing namespace probably does adequate cleanup. Try modules
  to start.
