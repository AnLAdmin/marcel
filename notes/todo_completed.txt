- Pipline pickling (replace/restore function)

- PickleableException (transmission of stacks): Stacks aren't
  reported, but errors are now transmissible.

- remove_cr_lf

- clone (pickling)

- scp, ssh via spawning. Is there a native way to do this?

- print_stack

- Forks

- Write OshArgParser.exit to avoid SystemExit on argparse error.

- CommandKiller shouldn't print stack. (dev only),
  default_exception_handler too.

- Get rid of default and related exception handlers? (See ideas.txt on replacing stderr.)

----------------------------------------------------------------------

yield is more expensive than send/receive. See
experiments/sendreceive_vs_yield.py.

----------------------------------------------------------------------

Instead of stdout, stderr: One output stream. stdout -> stream as
is. stderr -> Error objects.

KillAndResumeException does some things right. Raises an exception and
allows for continuation of the command. What's wrong: Prints to
stderr, which isn't all that helpful. Really want to pass the error
along through ops until it hopefully reaches an out. So send/receive
needs to check for errors and pass them through.

UPDATE:

OK, now OshErrors show up in the stream:

    > gen 3 -1 | map (x: 5 / x)
    -5.0
    map(x: 5 / x) failed on (0,): division by zero
    5.0

The middle line of output is an OshError object. This enables testing
for errors, filtering them out, redirecting them to a file, etc.

But if the error happens remotely:

    > @jao [ gen 3 -1 | map (x: 5 / x) ]
    (localhost, -5.0)
    (localhost, map(x: 5 / x) failed on (0,): division by zero)
    (localhost, 5.0)

The error is now embedded and harder to test for. 

Idea:

- OshError is always embedded, typically in a 1-tuple.

- Testing for error looks for an OshError anywhere inside the tuple.

----------------------------------------------------------------------

- ctrl-c handling

----------------------------------------------------------------------\

namespace

----------------------------------------------------------------------

More modern string formatting

----------------------------------------------------------------------

Symlink: Include referenced file

----------------------------------------------------------------------

~ expansion

----------------------------------------------------------------------

- cd with no args.

----------------------------------------------------------------------

- What are the rules for ls & symbolic links? Need some equivalent to
  bash "ls -ld"?

----------------------------------------------------------------------

- File comparisons need to account for display_base.

----------------------------------------------------------------------

- Tab completion for ops should tailor the list to whether the op
  being completed is first in the pipline, or downstream. E.g., don't
  show select as a first op.


----------------------------------------------------------------------

.marcel.py has to use env vars as VAR.value. Any way to get rid of
.value? Or at least import it syntactically? E.g. $(VAR) wouldn't be
bad, but $ is not legal in an identifier.

EASY: Just update the namespace directly, when env vars are updated!
Also need to clear all Function.functions, so that they get
regenerated with the updated namespace. (Is this right? Need to
experiment.)

----------------------------------------------------------------------

File object uses os.stat/lstat. When a file is transmitted, stat
result should be cached in the file, and then not overridden on the
receving side. So the File needs to have a field indicating if it has
been transmitted/reconstructed.

----------------------------------------------------------------------

- ^emacs works -- a new window running GUI emacs is created. So does
  ^emacs -nw, doing exactly the right thing (non-graphical, in current
  terminal). But ^vi does not. Nothing appears to happen. But vi is
  listening for input, so :q exits. stderr complains about not being a
  terminal, but this isn't visible. Vi DOES work if subprocess.run
  omits stdout=PIPE and stderr=PIPE.

----------------------------------------------------------------------

- .marcel.py might want a cluster named jao and a terminal profile
  named jao. Need separate namespaces for these things.

----------------------------------------------------------------------

- pushd/popd

----------------------------------------------------------------------

Get rid of "from ... import ..."

----------------------------------------------------------------------

Tab completion for flags of executables.

----------------------------------------------------------------------

Clean up parser to prepare for more general handling of pipelines:

- @fork [ ... ] currently:

    - fork_start and fork_spec grammar states and actions.
    
    - InProgress has fork_spec field.

    - finish_pipeline assumes that a fork op is being completed.

- Generalize:

    + Treat fork like any other op. START action creates an op just
      like for a string. Don't need START_FORK and FORK_SPEC states.

    + Choice between LocalFork and RemoteFork can't be done by
      create_fork.  Keep choice inside Fork op, delegate instead of
      inherit.

    + Fork has to be a more standard op. The only thing special about it
      is the syntax used to invoke it, @.

    + create_op also has some op-specific logic, distinguishing op
      from executable, and using the bash operator in the latter case.

    + finish_pipeline: Remove special handling of fork op. The
      pipeline just goes into op.args.


----------------------------------------------------------------------

cd doesn't work because it's running in a Process. Doesn't affect the
env visible to the main process.

----------------------------------------------------------------------

red needs a counting primitive.

    ... | f (x: 1) | red +

is too verbose and arcane for something so common. Something like:

   ... | red #

Except that # is typically a shell comment marker.

Define a "count" function?

----------------------------------------------------------------------

- Markup 2.0.

- Modify docs to use the markup 2.0.

- Get rid of define_color, define_prompt, define_continuation_prompt.

- Merge env and config. Env vars are just top-level symbols in the
  namespace.



Env, config, global_state:

main: 

    - self.env = Environment(config_path)

    - self.global_state = GlobalState(env)

    - Main loop calls self.env.prompts() which mostly delegates to config.

    - Execution passes self.global_state to parser.

    - Main defines update_env_vars, which is used by JobControl to update
      vars modified by Job running in another process. These call env.setvar
      which then ends up in config.

env:

    - Reads parts of environment (user, host, homedir, current dir)

    - __init__ gets config_path from caller (main)

    - Sets env vars, self._vars

    - Create config and store in self._config.

    - self._color_scheme = color scheme from config.

    - Implements current dir operations: cd, pushd, popd, dirs,
      pwd. Dir stack is maintained in config, as a var. Problem with
      this approach: User can modify it directly, unless setvar() 
      checks for it. Same with PWD, which works in bash, but leads to
      weird results, e.g.

            jao@cheese:~$ PWD=/tmp
            jao@cheese:/tmp$ pwd
            /home/jao

    - Access to cluster, config, color_scheme, all of which reside in config.

config:

    - Has self._env_vars, prompt, continuation prompt.

    - self.function_namesspace is the namespace in which commands run. Defined by
      executing .marcel.py, in read_config. 

    - read_config puts Color, PROMPT, PROMPT_CONTINUATION, COLOR_SCHEME, define_cluster
      in globals(), passes to exec(.marcel.py). Then, COLOR_SCHEMA is put in function namespace.
      Should probably put everything there.

GlobalState:

    - Attached to parser, pipelines, available everywhere as a result.

    - Has env, edited_command, op_modules.

    - Provides function_namespace via delegation.


Cleanup:

+ Merge Environment and Configuration. Get rid of Configuration.

+ Put directory logic into its own class.

+ Replace GlobalState by Environment. Move GlobalState fields into
  Environment.

+ After execing .marcel.py, copy locals into globals. globals replaces
  function_namespace.

+ Move VERSION from env to an environment variable, MARCEL_VERSION.

